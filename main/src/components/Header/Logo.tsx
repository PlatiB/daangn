import { useCallback, useMemo } from 'react';
import styles from './Logo.module.css';

/**
 * 당근마켓 로고 컴포넌트
 * 당근 아이콘과 텍스트를 포함한 클릭 가능한 로고
 *
 * 🎯 성능 최적화 적용:
 * - useCallback: 이벤트 핸들러 함수 메모이제이션
 * - useMemo: 복잡한 JSX 요소 메모이제이션
 */
function Logo() {

  /**
   * 🔧 useCallback 최적화
   * - 목적: 함수 재생성 방지
   * - 효과: 컴포넌트가 리렌더링되어도 동일한 함수 참조 유지
   * - 의존성: [] (빈 배열) - 함수가 절대 변경되지 않음
   */
  const handleLogoClick = useCallback(() => {
    // 홈으로 이동
    window.location.href = '/';
  }, []); // ✅ 의존성 없음 - 함수 내용이 외부 값에 의존하지 않음

  /**
   * 🔧 useCallback 최적화 (의존성 있음)
   * - 목적: 키보드 이벤트 핸들러 메모이제이션
   * - 의존성: [handleLogoClick] - handleLogoClick이 변경될 때만 재생성
   * - 주의: handleLogoClick도 useCallback으로 최적화되어 있어 안정적
   */
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleLogoClick();
    }
  }, [handleLogoClick]); // ✅ handleLogoClick을 의존성으로 명시

  /**
   * 🎨 useMemo 최적화
   * - 목적: 복잡한 SVG 요소를 메모이제이션하여 불필요한 재생성 방지
   * - 효과: 부모 컴포넌트가 리렌더링되어도 SVG DOM 재계산 방지
   * - 의존성: [] (빈 배열) - 정적 SVG이므로 절대 변경되지 않음
   *
   * 💡 언제 useMemo를 사용해야 하나?
   * 1. 계산 비용이 높은 연산의 결과를 캐싱할 때
   * 2. 참조 동일성이 중요한 객체/배열을 생성할 때
   * 3. 복잡한 JSX 구조를 메모이제이션할 때 (현재 케이스)
   */
  const logoSvg = useMemo(() => (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="64"
      fill="none"
      viewBox="0 0 203 114"
      className={styles.logoSvg}
    >
      {/* 당근 아이콘 부분 */}
      <path
        fill="#FF6F0F"
        d="M29.234 36.895C13.09 36.895 0 49.695 0 65.855c0 22.327 29.318 34.175 29.234 34.143-.08.032 29.234-11.816 29.234-34.143 0-16.148-13.089-28.96-29.234-28.96Zm0 40.684A11.069 11.069 0 0 1 18.386 64.34a11.073 11.073 0 0 1 8.702-8.693A11.068 11.068 0 0 1 40.312 66.51a11.07 11.07 0 0 1-11.078 11.088v-.02Z"
      />
      <path
        fill="#00A05B"
        d="M35.817 0c-6.823 0-11.574 4.768-12.322 10.4-9.094-2.512-16.22 4.4-16.22 12 0 5.82 3.999 10.52 9.33 12.047 4.299 1.228 12.041.312 12.041.312-.04-1.88 1.692-3.944 4.364-5.824 7.598-5.343 13.54-7.863 14.457-15.151C48.427 6.16 42.767 0 35.817 0Z"
      />
      {/* "마켓" 텍스트 부분 */}
      <path
        fill="#FF6F0F"
        d="M116.493 46.963c-6.175 1.94-16.865 2.972-26.907 2.972V37.719h20.74v-9.096H78.465V59.6c17.424 0 32.637-2.1 39.06-4.088l-1.032-8.548ZM131.134 25h-11.106v35.61h11.106V49.448h8.958v-9.716h-8.958V25ZM110.506 60.527c-11.766 0-20.396 6.484-20.396 16 0 9.515 8.639 16 20.396 16 11.758 0 20.396-6.489 20.396-16 0-9.512-8.63-16-20.396-16Zm0 23.091c-5.303 0-9.282-2.544-9.282-7.108 0-4.563 3.979-7.103 9.282-7.103s9.282 2.544 9.282 7.103c0 4.56-3.975 7.108-9.282 7.108ZM161.72 65.25h-11.354v24.092h45.128v-9.536H161.72V65.251ZM194.086 27.971h-44.232v9.536h33.082c0 2.368.112 8-.972 14.4h-40.568v9.864h61.588v-9.848H192.01c1.472-8.088 1.892-14.392 2.076-23.952Z"
      />
    </svg>
  ), []); // ✅ 빈 의존성 배열 - SVG가 props나 state에 의존하지 않음

  return (
    <div
      className={styles.logo}
      onClick={handleLogoClick}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={0}
      aria-label="당근"
    >
      {/* 메모이제이션된 SVG 로고 렌더링 */}
      {logoSvg}
    </div>
  );
}

export default Logo;